package main

import (
	"bytes"
	"encoding/json"
	"io"
	"net/http"

	"github.com/maxence-charriere/go-app/v9/pkg/app"
)

const (
	searchEndpoint = "/vsearch"
)

// SearchResult represents a single search result.
type SearchResult struct {
	Text          string  `json:"text"`
	DocumentIndex int     `json:"documentIndex"`
	Score         float64 `json:"score"`
}

// Document represents a single document.
type Document struct {
	ID       string `json:"id"`
	Metadata []struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"metadata"`
}

// ResponseData represents the response data from the API.
type ResponseData struct {
	ResponseSet []struct {
		Response []SearchResult `json:"response"`
		Document []Document     `json:"document"`
		Summary  []struct {
			Text string `json:"text"`
		} `json:"summary"`
	} `json:"responseSet"`
	Status  []interface{} `json:"status"`
	Metrics interface{}   `json:"metrics"`
}

func handleSearch(ctx app.Context, a app.Action) {

	query := a.Tags.Get("query")
	if query == "" {
		app.Log("Empty query")
		return
	}

	// Generate state key based on query.
	state := searchState(query)

	// Retrieve search content from state.
	var results searchResults
	//ctx.GetState(state, &results)

	app.Log(results.Status)
	// Update search status to loading.
	results.Status = loading
	results.Err = nil

	app.Log("Status %d", results.Status)
	ctx.SetState(state, &results)

	// Perform the search operation.
	// Example: res, err := performSearch(ctx, query)
	// Update results accordingly.

	// For demonstration purposes, we'll simulate a delay.
	// Replace this with your actual search operation.
	go func() {
		url := "https://api.vectara.io/v1/query"
		method := "POST"

		payloadMap := map[string]interface{}{
			"query": []map[string]interface{}{
				{
					"query":        query,
					"queryContext": "",
					"start":        0,
					"numResults":   3,
					"contextConfig": map[string]interface{}{
						"charsBefore":     0,
						"charsAfter":      0,
						"sentencesBefore": 2,
						"sentencesAfter":  2,
					},
					"rerankingConfig": map[string]interface{}{
						"rerankerId": 272725718,
						"mmrConfig": map[string]interface{}{
							"diversityBias": 0,
						},
					},
					"corpusKey": []map[string]interface{}{
						{
							"customerId":     2523211369,
							"corpusId":       12,
							"semantics":      0,
							"metadataFilter": "",
							"lexicalInterpolationConfig": map[string]interface{}{
								"lambda": .025,
							},
							"dim": []interface{}{},
						},
					},
					"summary": []map[string]interface{}{
						{
							"maxSummarizedResults": 5,
							"responseLang":         "auto",
							"summarizerPromptName": "vectara-summary-ext-v1.2.0",
						},
					},
				},
			}}

		payloadJSON, err := mapToJSON(payloadMap)
		if err != nil {
			app.Log("Error converting payload to JSON:", err)
			return
		}

		payload := bytes.NewReader([]byte(payloadJSON))

		client := &http.Client{}
		req, err := http.NewRequest(method, url, payload)
		if err != nil {
			app.Log(err)
			return
		}

		req.Header.Add("Content-Type", "application/json")
		req.Header.Add("Accept", "application/json")
		req.Header.Add("x-api-key", "zwt_lmUmaZXsE_PkhRRjH7ryw8a9dNXYgDXtavC1cw")
		req.Header.Add("customer-id", "2523211369")

		res, err := client.Do(req)
		if err != nil {
			app.Log(err)
			return
		}
		defer res.Body.Close()

		body, err := io.ReadAll(res.Body)
		if err != nil {
			app.Log(err)
			return
		}

		app.Log("Response:", string(body))

		var responseData ResponseData
		if err := json.Unmarshal(body, &responseData); err != nil {
			app.Log("Error unmarshalling JSON:", err)
			return
		}

		results.Status = loaded
		results.Results = body

		app.Log("New status %d", results.Status)
		ctx.SetState(state, &results)
		//	updateSearchResults(ctx, state, body)

		// Update search results in the component.
		//s.SummaryText = responseData.ResponseSet[0].Summary[0].Text
		//s.SearchResults = responseData.ResponseSet[0].Response
		//s.Documents = responseData.ResponseSet[0].Document

	}()
}

// mapToJSON converts a map to a JSON string.
func mapToJSON(m map[string]interface{}) (string, error) {
	jsonBytes, err := json.Marshal(m)
	if err != nil {
		return "", err
	}
	return string(jsonBytes), nil
}

// State key generator function.
func searchState(query string) string {
	return query
}

// Helper function to update search results in state.
func updateSearchResults(ctx app.Context, state string, results []byte) {
	// Retrieve current search results.
	var current searchResults
	ctx.GetState(state, &current)

	// Update search results.
	current.Results = results
	current.Status = loaded

	// Update state with new search results.
	ctx.SetState(state, current)
}

// Data structure to manage search results.
type searchResults struct {
	Status  status // Search status (loading, loaded, error, etc.)
	Err     error  // Error if search failed
	Results []byte // Search results
}
